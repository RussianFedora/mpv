From d797d59b8380fca51ecdbd75ac5d0ed33e096f6d Mon Sep 17 00:00:00 2001
From: George Sedov <radist.morse@gmail.com>
Date: Mon, 4 May 2015 14:21:03 +0300
Subject: [PATCH 1/2] lua: make more compatible with lua 5.3

Lua 5.3 introduced stricter integer typisation which leaded to some
errors in osc modules. pushnumber was changed to pushinteger where
applicable, math.floor was used to forcibly convert floats to ints,
an explicit typecast to lua_Integer was introduced in places where
the error might occure with lua compiled with 32bit ints, and
finally, one special corner case in get_screen_size which leaded
to division by zero was taken care of.
---
 player/lua.c       | 51 ++++++++++++++++++++++++++++++---------------------
 player/lua/osc.lua | 28 ++++++++++++++--------------
 2 files changed, 44 insertions(+), 35 deletions(-)

diff --git a/player/lua.c b/player/lua.c
index 4ef772f..49e65fc 100644
--- a/player/lua.c
+++ b/player/lua.c
@@ -474,6 +474,12 @@ static int script_resume_all(lua_State *L)
 
 static void pushnode(lua_State *L, mpv_node *node);
 
+static bool is_int(double d)
+{
+    lua_Integer v = d;
+    return d == (double)v;
+}
+
 static int script_wait_event(lua_State *L)
 {
     struct script_ctx *ctx = get_ctx(L);
@@ -485,7 +491,7 @@ static int script_wait_event(lua_State *L)
     lua_setfield(L, -2, "event"); // event
 
     if (event->reply_userdata) {
-        lua_pushnumber(L, event->reply_userdata);
+        lua_pushinteger(L, (lua_Integer)event->reply_userdata);
         lua_setfield(L, -2, "id");
     }
 
@@ -527,7 +533,10 @@ static int script_wait_event(lua_State *L)
             pushnode(L, prop->data);
             break;
         case MPV_FORMAT_DOUBLE:
-            lua_pushnumber(L, *(double *)prop->data);
+            if (is_int(*(double *)prop->data))
+                lua_pushinteger(L, *(lua_Integer *)prop->data);
+            else
+                lua_pushnumber(L, *(double *)prop->data);
             break;
         case MPV_FORMAT_FLAG:
             lua_pushboolean(L, *(int *)prop->data);
@@ -617,12 +626,6 @@ static int script_set_property_bool(lua_State *L)
     return check_error(L, mpv_set_property(ctx->client, p, MPV_FORMAT_FLAG, &v));
 }
 
-static bool is_int(double d)
-{
-    int64_t v = d;
-    return d == (double)v;
-}
-
 static int script_set_property_number(lua_State *L)
 {
     struct script_ctx *ctx = get_ctx(L);
@@ -812,7 +815,10 @@ static int script_get_property_number(lua_State *L)
     double result = 0;
     int err = mpv_get_property(ctx->client, name, MPV_FORMAT_DOUBLE, &result);
     if (err >= 0) {
-        lua_pushnumber(L, result);
+        if (is_int(result))
+            lua_pushinteger(L, (lua_Integer)result);
+        else
+            lua_pushnumber(L, result);
         return 1;
     } else {
         lua_pushvalue(L, 2);
@@ -830,7 +836,7 @@ static void pushnode(lua_State *L, mpv_node *node)
         lua_pushstring(L, node->u.string);
         break;
     case MPV_FORMAT_INT64:
-        lua_pushnumber(L, node->u.int64);
+        lua_pushinteger(L, (lua_Integer)node->u.int64);
         break;
     case MPV_FORMAT_DOUBLE:
         lua_pushnumber(L, node->u.double_);
@@ -922,7 +928,7 @@ static int script_raw_unobserve_property(lua_State *L)
 {
     struct script_ctx *ctx = get_ctx(L);
     uint64_t id = luaL_checknumber(L, 1);
-    lua_pushnumber(L, mpv_unobserve_property(ctx->client, id));
+    lua_pushinteger(L, mpv_unobserve_property(ctx->client, id));
     return 1;
 }
 
@@ -962,8 +968,8 @@ static int script_get_osd_resolution(lua_State *L)
     struct MPContext *mpctx = get_mpctx(L);
     int w, h;
     osd_object_get_resolution(mpctx->osd, OSDTYPE_EXTERNAL, &w, &h);
-    lua_pushnumber(L, w);
-    lua_pushnumber(L, h);
+    lua_pushinteger(L, w);
+    lua_pushinteger(L, h);
     return 2;
 }
 
@@ -971,10 +977,13 @@ static int script_get_screen_size(lua_State *L)
 {
     struct MPContext *mpctx = get_mpctx(L);
     struct mp_osd_res vo_res = osd_get_vo_res(mpctx->osd, OSDTYPE_EXTERNAL);
-    double aspect = 1.0 * vo_res.w / MPMAX(vo_res.h, 1) /
-                    (vo_res.display_par ? vo_res.display_par : 1);
-    lua_pushnumber(L, vo_res.w);
-    lua_pushnumber(L, vo_res.h);
+    double aspect = 1.0;
+    if ((vo_res.w > 0) && (vo_res.h > 0))
+        aspect = 1.0 * vo_res.w / vo_res.h /
+                 (vo_res.display_par ? vo_res.display_par : 1);
+
+    lua_pushinteger(L, vo_res.w);
+    lua_pushinteger(L, vo_res.h);
     lua_pushnumber(L, aspect);
     return 3;
 }
@@ -983,10 +992,10 @@ static int script_get_screen_margins(lua_State *L)
 {
     struct MPContext *mpctx = get_mpctx(L);
     struct mp_osd_res vo_res = osd_get_vo_res(mpctx->osd, OSDTYPE_EXTERNAL);
-    lua_pushnumber(L, vo_res.ml);
-    lua_pushnumber(L, vo_res.mt);
-    lua_pushnumber(L, vo_res.mr);
-    lua_pushnumber(L, vo_res.mb);
+    lua_pushinteger(L, vo_res.ml);
+    lua_pushinteger(L, vo_res.mt);
+    lua_pushinteger(L, vo_res.mr);
+    lua_pushinteger(L, vo_res.mb);
     return 4;
 }
 
diff --git a/player/lua/osc.lua b/player/lua/osc.lua
index 4aade7c..d69a09c 100644
--- a/player/lua/osc.lua
+++ b/player/lua/osc.lua
@@ -11,12 +11,12 @@ local opt = require 'mp.options'
 local user_opts = {
     showwindowed = true,        -- show OSC when windowed?
     showfullscreen = true,      -- show OSC when fullscreen?
-    scalewindowed = 1,          -- scaling of the controller when windowed
-    scalefullscreen = 1,        -- scaling of the controller when fullscreen
-    scaleforcedwindow = 2,      -- scaling when rendered on a forced window
+    scalewindowed = 1.,         -- scaling of the controller when windowed
+    scalefullscreen = 1.,       -- scaling of the controller when fullscreen
+    scaleforcedwindow = 2.,     -- scaling when rendered on a forced window
     vidscale = true,            -- scale the controller with the video?
     valign = 0.8,               -- vertical alignment, -1 (top) to 1 (bottom)
-    halign = 0,                 -- horizontal alignment, -1 (left) to 1 (right)
+    halign = 0.,                -- horizontal alignment, -1 (left) to 1 (right)
     boxalpha = 80,              -- alpha of the background box,
                                 -- 0 (opaque) to 255 (fully transparent)
     hidetimeout = 500,          -- duration in ms until the OSC hides if no
@@ -38,7 +38,7 @@ read_options(user_opts, "osc")
 local osc_param = { -- calculated by osc_init()
     playresy = 0,                           -- canvas size Y
     playresx = 0,                           -- canvas size X
-    display_aspect = 1,
+    display_aspect = 1.,
     areas = {},
 }
 
@@ -189,7 +189,7 @@ end
 
 -- multiplies two alpha values, formular can probably be improved
 function mult_alpha(alphaA, alphaB)
-    return 255 - (((1-(alphaA/255)) * (1-(alphaB/255))) * 255)
+    return math.floor(255 - (((1-(alphaA/255)) * (1-(alphaB/255))) * 255))
 end
 
 function add_area(name, x1, y1, x2, y2)
@@ -739,8 +739,8 @@ layouts["box"] = function ()
 
     -- make sure the OSC actually fits into the video
     if (osc_param.playresx < (osc_geo.w + (2 * osc_geo.p))) then
-        osc_param.playresy = (osc_geo.w+(2*osc_geo.p))/osc_param.display_aspect
-        osc_param.playresx = osc_param.playresy * osc_param.display_aspect
+        osc_param.playresy = math.floor((osc_geo.w+(2*osc_geo.p))/osc_param.display_aspect)
+        osc_param.playresx = math.floor(osc_param.playresy * osc_param.display_aspect)
     end
 
     -- position of the controller according to video aspect and valignment
@@ -907,8 +907,8 @@ layouts["slimbox"] = function ()
 
     -- make sure the OSC actually fits into the video
     if (osc_param.playresx < (osc_geo.w)) then
-        osc_param.playresy = (osc_geo.w)/osc_param.display_aspect
-        osc_param.playresx = osc_param.playresy * osc_param.display_aspect
+        osc_param.playresy = math.floor((osc_geo.w)/osc_param.display_aspect)
+        osc_param.playresx = math.floor(osc_param.playresy * osc_param.display_aspect)
     end
 
     -- position of the controller according to video aspect and valignment
@@ -1297,11 +1297,11 @@ function osc_init()
     end
 
     if user_opts.vidscale then
-        osc_param.playresy = baseResY / scale
+        osc_param.playresy = math.floor(baseResY / scale)
     else
-        osc_param.playresy = display_h / scale
+        osc_param.playresy = math.floor(display_h / scale)
     end
-    osc_param.playresx = osc_param.playresy * display_aspect
+    osc_param.playresx = math.floor(osc_param.playresy * display_aspect)
     osc_param.display_aspect = display_aspect
 
 
@@ -1800,7 +1800,7 @@ function render()
     end
 
     -- submit
-    mp.set_osd_ass(osc_param.playresy * aspect, osc_param.playresy, ass.text)
+    mp.set_osd_ass(math.floor(osc_param.playresy * aspect), osc_param.playresy, ass.text)
 
 
 

From 003a9ac8dc42b06ab89f2e0ac719bb7ed259da91 Mon Sep 17 00:00:00 2001
From: George Sedov <radist.morse@gmail.com>
Date: Mon, 4 May 2015 15:51:13 +0300
Subject: [PATCH 2/2] lua: fix the wrong typecast

---
 player/lua.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/player/lua.c b/player/lua.c
index 49e65fc..8ae01cd 100644
--- a/player/lua.c
+++ b/player/lua.c
@@ -534,7 +534,7 @@ static int script_wait_event(lua_State *L)
             break;
         case MPV_FORMAT_DOUBLE:
             if (is_int(*(double *)prop->data))
-                lua_pushinteger(L, *(lua_Integer *)prop->data);
+                lua_pushinteger(L, (lua_Integer)(*(double *)(prop->data)));
             else
                 lua_pushnumber(L, *(double *)prop->data);
             break;
